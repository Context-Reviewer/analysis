from __future__ import annotations

import json
import html
from pathlib import Path
from collections import Counter

ENRICHED = Path("fb_extract_out/sean_context_enriched.v2.jsonl")

# Existing metrics (already generated by your pipeline)
BM = Path("docs/data/behavioral_metrics.json")
BM2 = Path("docs/data/behavioral_metrics_v0_2.json")
BM3 = Path("docs/data/behavioral_metrics_v0_3.json")
DQM = Path("docs/data/data_quality_metrics.json")

OUT_JSON = Path("docs/data/conclusion.json")
OUT_HTML = Path("docs/conclusion.html")

HOSTILE_THRESHOLD = -0.6
MAX_EXAMPLES_PER_SECTION = 6

def fail(msg: str) -> None:
    raise SystemExit(f"[FAIL] {msg}")

def esc(s: str) -> str:
    return html.escape(s or "", quote=True)

def load_json(path: Path) -> dict:
    if not path.exists():
        fail(f"Missing required JSON: {path}")
    return json.loads(path.read_text(encoding="utf-8"))

def load_jsonl(path: Path) -> list[dict]:
    if not path.exists():
        fail(f"Missing required JSONL: {path}")
    rows = []
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line:
            continue
        rows.append(json.loads(line))
    return rows

def preview(s: str, n: int = 240) -> str:
    s = (s or "").strip()
    return s if len(s) <= n else (s[:n].rstrip() + "…")

def main() -> None:
    # Load enriched rows (canonical for topic + thread ownership + excerpts)
    rows = load_jsonl(ENRICHED)

    # Keep comments only for conclusion notes (consistent with report)
    comments = [r for r in rows if r.get("joined_item_type") == "comment"]
    if not comments:
        fail("No comment rows found in enriched file (joined_item_type == 'comment').")

    # Pull core stats from existing metric outputs (fail-loud if missing)
    bm = load_json(BM)
    bm3 = load_json(BM3)
    dqm = load_json(DQM)

    # Deterministic rollups
    primary_topics = [ (r.get("thread_primary_topic") or "").strip() for r in comments ]
    primary_topics = [t for t in primary_topics if t]
    topic_counts = Counter(primary_topics)

    sentiments = []
    hostile = 0
    for r in comments:
        try:
            v = float(r.get("sentiment_compound"))
        except Exception:
            continue
        sentiments.append(v)
        if v < HOSTILE_THRESHOLD:
            hostile += 1

    hostile_rate = (hostile / len(sentiments) * 100.0) if sentiments else 0.0

    # Thread ownership counts (already encoded by context_enrich)
    # parent_author_type expected: "self" or "other" (from your enrichment)
    pat = Counter((r.get("parent_author_type") or "").strip() for r in comments)
    reply_self = int(pat.get("self", 0))
    reply_other = int(pat.get("other", 0))

    # Example selection: deterministic (timeline_i then source_index)
    def sk(r: dict) -> tuple[int, int]:
        try:
            ti = int(r.get("timeline_i") or 10**9)
        except Exception:
            ti = 10**9
        try:
            si = int(r.get("source_index") or 0)
        except Exception:
            si = 0
        return (ti, si)

    comments_sorted = sorted(comments, key=sk)

    # Examples: most hostile
    hostile_examples = []
    for r in sorted(comments_sorted, key=lambda x: (float(x.get("sentiment_compound", 0.0)),) + sk(x)):
        try:
            if float(r.get("sentiment_compound")) < HOSTILE_THRESHOLD:
                hostile_examples.append(r)
        except Exception:
            continue
        if len(hostile_examples) >= MAX_EXAMPLES_PER_SECTION:
            break

    # Examples: most common topic (top 1)
    top_topic = topic_counts.most_common(1)[0][0] if topic_counts else ""
    top_topic_examples = []
    if top_topic:
        for r in comments_sorted:
            if (r.get("thread_primary_topic") or "").strip() == top_topic:
                top_topic_examples.append(r)
            if len(top_topic_examples) >= MAX_EXAMPLES_PER_SECTION:
                break

    conclusion = {
        "rows_total": len(rows),
        "comments_total": len(comments),
        "hostile_threshold": HOSTILE_THRESHOLD,
        "hostile_rate_pct": round(hostile_rate, 1),
        "top_primary_topics": topic_counts.most_common(10),
        "reply_to_self_count": reply_self,
        "reply_to_other_count": reply_other,
        "data_quality": {
            # keep this minimal; it's already computed upstream
            "missing_any_time": dqm.get("missing_any_time"),
            "time_coverage_first": dqm.get("time_coverage_first"),
            "time_coverage_last": dqm.get("time_coverage_last"),
        },
        "examples": {
            "hostile": [
                {
                    "timeline_i": r.get("timeline_i"),
                    "thread_permalink": r.get("thread_permalink"),
                    "primary_topic": (r.get("thread_primary_topic") or ""),
                    "sentiment_compound": r.get("sentiment_compound"),
                    "excerpt": preview(r.get("body") or ""),
                }
                for r in hostile_examples
            ],
            "top_primary_topic": top_topic,
            "top_primary_topic_examples": [
                {
                    "timeline_i": r.get("timeline_i"),
                    "thread_permalink": r.get("thread_permalink"),
                    "primary_topic": (r.get("thread_primary_topic") or ""),
                    "sentiment_compound": r.get("sentiment_compound"),
                    "excerpt": preview(r.get("body") or ""),
                }
                for r in top_topic_examples
            ],
        },
        "fingerprints": {
            "behavioral_metrics_fingerprint": bm.get("fingerprint"),
            "behavioral_metrics_v0_3_fingerprint": bm3.get("fingerprint"),
        }
    }

    OUT_JSON.parent.mkdir(parents=True, exist_ok=True)
    OUT_JSON.write_text(json.dumps(conclusion, ensure_ascii=False, indent=2), encoding="utf-8")

    # Render HTML using site primitives
    # NOTE: Explicit caveat language to avoid “personality diagnosis” framing.
    topics_rows = "".join(
        f"<tr><td>{esc(t)}</td><td>{c}</td></tr>"
        for (t, c) in conclusion["top_primary_topics"]
    )

    def render_examples(exs: list[dict]) -> str:
        if not exs:
            return "<p>(none)</p>"
        rows = []
        for e in exs:
            link = e.get("thread_permalink") or ""
            link_html = f'<a href="{esc(link)}">link</a>' if link else ""
            rows.append(
                "<tr>"
                f"<td>{esc(str(e.get('timeline_i') or ''))}</td>"
                f"<td>{esc(str(e.get('primary_topic') or ''))}</td>"
                f"<td>{esc(str(e.get('sentiment_compound') or ''))}</td>"
                f"<td>{link_html}</td>"
                f"<td>{esc(str(e.get('excerpt') or ''))}</td>"
                "</tr>"
            )
        return (
            "<table><thead><tr>"
            "<th>timeline_i</th><th>topic</th><th>sentiment</th><th>thread</th><th>excerpt</th>"
            "</tr></thead><tbody>"
            + "".join(rows) +
            "</tbody></table>"
        )

    html_doc = f"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Conclusion</title>
  <link rel="stylesheet" href="assets/style.css"/>
  <script src="assets/site.js" defer></script>
</head>
<body>
  <header class="topnav">
    <div class="brand">Context Reviewer</div>
    <nav>
      <a href="index.html">Home</a>
      <a href="report.html">Report</a>
      <div class="dropdown">
        <a href="#">Topics ▾</a>
        <div class="dropdown-content">
          <a href="topics/israel.html">Israel / Palestine</a>
          <a href="topics/race.html">Race & Identity</a>
          <a href="topics/religion.html">Religion</a>
        </div>
      </div>
      <a href="contradictions.html">Contradictions</a>
      <a href="conclusion.html" class="active">Conclusion</a>
    </nav>
  </header>

  <main class="container">
    <h1>Conclusion</h1>

    <section class="panel">
      <h2>Scope and caveats</h2>
      <p>
        This page summarizes observable patterns in the dataset only.
        It does not diagnose personality, infer intent, or make clinical or psychological claims.
        All statements should be traceable to measurable counts or example excerpts.
      </p>
    </section>

    <section class="panel">
      <h2>Dataset summary</h2>
      <table>
        <tbody>
          <tr><th>Total enriched rows</th><td>{conclusion["rows_total"]}</td></tr>
          <tr><th>Comment rows analyzed</th><td>{conclusion["comments_total"]}</td></tr>
          <tr><th>Hostile threshold</th><td>{HOSTILE_THRESHOLD}</td></tr>
          <tr><th>Hostile rate</th><td>{conclusion["hostile_rate_pct"]}%</td></tr>
          <tr><th>Replies to self (thread is subject post)</th><td>{conclusion["reply_to_self_count"]}</td></tr>
          <tr><th>Replies to others (thread not subject post)</th><td>{conclusion["reply_to_other_count"]}</td></tr>
          <tr><th>Time coverage first</th><td>{esc(str(conclusion["data_quality"]["time_coverage_first"] or ""))}</td></tr>
          <tr><th>Time coverage last</th><td>{esc(str(conclusion["data_quality"]["time_coverage_last"] or ""))}</td></tr>
        </tbody>
      </table>
    </section>

    <section class="panel">
      <h2>Top primary topics (comments)</h2>
      <table>
        <thead><tr><th>topic</th><th>count</th></tr></thead>
        <tbody>
          {topics_rows}
        </tbody>
      </table>
    </section>

    <section class="panel">
      <h2>Examples: hostile excerpts (sentiment &lt; {HOSTILE_THRESHOLD})</h2>
      {render_examples(conclusion["examples"]["hostile"])}
    </section>

    <section class="panel">
      <h2>Examples: most common primary topic — {esc(conclusion["examples"]["top_primary_topic"] or "")}</h2>
      {render_examples(conclusion["examples"]["top_primary_topic_examples"])}
    </section>

    <section class="panel">
      <h2>Observed communication patterns (dataset-bounded)</h2>
      <ul>
        <li>
          <strong>Primary engagement mode:</strong>
          Most common primary topic is <code>{esc(conclusion["examples"]["top_primary_topic"] or "")}</code>
          (see topic distribution above; drill down via <a href="report.html">Report</a>).
        </li>
        <li>
          <strong>Reply orientation:</strong>
          Replies in subject-owned threads: <code>{conclusion["reply_to_self_count"]}</code>;
          replies in others’ threads: <code>{conclusion["reply_to_other_count"]}</code>.
          (This is derived from <code>parent_author_type</code> in enriched artifacts.)
        </li>
        <li>
          <strong>Negativity concentration:</strong>
          Hostile-rate at threshold <code>{HOSTILE_THRESHOLD}</code> is <code>{conclusion["hostile_rate_pct"]}%</code>.
          See examples below for traceable excerpts.
        </li>
        <li>
          <strong>Topic drilldown:</strong>
          Category pages: <a href="topics/religion.html">Religion</a>,
          <a href="topics/race.html">Race</a>,
          <a href="topics/israel.html">Israel/Palestine</a>.
        </li>
      </ul>
      <p>
        Notes are descriptive only: no claims about stable traits, intent, or psychology.
      </p>
    </section>

    <section class="panel">
      <h2>Reproducibility</h2>
      <table>
        <tbody>
          <tr><th>behavioral_metrics fingerprint</th><td>{esc(str(conclusion["fingerprints"]["behavioral_metrics_fingerprint"] or ""))}</td></tr>
          <tr><th>behavioral_metrics_v0_3 fingerprint</th><td>{esc(str(conclusion["fingerprints"]["behavioral_metrics_v0_3_fingerprint"] or ""))}</td></tr>
        </tbody>
      </table>
      <p>
        All outputs are derived artifacts. No manual edits to outputs.
      </p>
    </section>
  </main>

  <footer class="footer">
    Generated report; patterns only; no inference of intent.
  </footer>
</body>
</html>
"""
    OUT_HTML.write_text(html_doc, encoding="utf-8")
    print(f"[OK] Wrote {OUT_JSON}")
    print(f"[OK] Wrote {OUT_HTML}")

if __name__ == "__main__":
    main()


